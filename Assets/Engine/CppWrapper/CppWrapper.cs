using System.IO;
using System.Linq;
using System.Text;
using CppAst;
using UnityEngine;

namespace CppWrapper
{
    public static class CppWrapper
    {
        public static string Generate(string dllName, string dllPath, string folderPath)
        {
            var headers = Directory.GetFiles(folderPath, "*.h", SearchOption.AllDirectories);

            var cppParserOptions = new CppParserOptions()
            {
                //ParseTokenAttributes = true, //Actual [[]] attributes, takes too long to compile
                ParseMacros = true,
                ParseCommentAttribute = true,
                ParseComments = true,
                AdditionalArguments = { "-std=c++17" }
            };
            var compilation = CppParser.ParseFiles(headers.ToList(), cppParserOptions);
        
            // Print diagnostic messages
            foreach (var message in compilation.Diagnostics.Messages
                         .Where(m => m.Type == CppLogMessageType.Error))
            {
                Debug.LogWarning(message.ToString());
            }

            var str = new StringBuilder();

            //TODO Only add necessary usings
            str.AppendLine(@$"//AUTOGENERATED//

using System;
using System.Runtime.InteropServices;
using UnityEngine;

public static unsafe class {dllName}
{{");
            str.AppendLine($"    private const string dllPath = \"{dllPath}\";");
            str.AppendLine("    private static IntPtr dllHandle = IntPtr.Zero;");
            str.AppendLine();
            
            foreach (var cppClass in compilation.Classes
                         .Where(c => c.Attributes.Any(a => a.Arguments == "[[EXPORT]]")))
            {
                AddStruct(cppClass, str);
            }

            var loadDelegates = new StringBuilder();
        
            foreach (var cppFunction in compilation.Functions
                         .Where(c => c.Attributes.Any(a => a.Arguments == "[[EXPORT]]")))
            {
                AddFunction(dllName, cppFunction, str, loadDelegates);
            }

            str.AppendLine(@$"    
    public static void Initialize()
    {{
        dllHandle = DllLoader.OpenLibrary(dllPath);

{loadDelegates}
    }}

    public static void Dispose()
    {{
        DllLoader.CloseLibrary(dllHandle);
    }}");
        
            str.AppendLine(@$"}}");

            return str.ToString();
        }

        private static void AddStruct(CppClass cppClass, StringBuilder str)
        {
            str.Append(@$"    public unsafe struct {cppClass.Name}
    {{
");

            foreach (var cppField in cppClass.Fields)
            {
                str.AppendLine($"       public {MapType(cppField.Type)} {cppField.Name};");
            }
        
            str.AppendLine(@$"    }}");
            str.AppendLine();
        }
    
        private static void AddFunction(string dllName, CppFunction cppFunction, StringBuilder str,
            StringBuilder loadDelegates)
        {
            loadDelegates.AppendLine(   @$"        {cppFunction.Name} = DllLoader.GetDelegate<{cppFunction.Name}Delegate>(dllHandle, ""{cppFunction.Name}"");");
            
            str.Append(   @$"    public delegate {MapType(cppFunction.ReturnType)} {cppFunction.Name}Delegate(");

            if (cppFunction.Parameters.Count > 0)
            {
                for (var index = 0; index < cppFunction.Parameters.Count - 1; index++)
                {
                    var cppParameter = cppFunction.Parameters[index];
                    str.Append($"{MapType(cppParameter.Type)} {cppParameter.Name}, ");
                }
        
                var lastCppParameter = cppFunction.Parameters[^1];
                str.Append($"{MapType(lastCppParameter.Type)} {lastCppParameter.Name}");
            }

            str.Append($");");
            str.AppendLine();

            str.AppendLine($@"    public static {cppFunction.Name}Delegate {cppFunction.Name};");
            str.AppendLine();
        }

        private static string MapType(CppType type)
        {
            if (type.TypeKind == CppTypeKind.Pointer && ((CppPointerType)type).ElementType.TypeKind == CppTypeKind.Function)
                return "void*";
            
            var name = type.FullName;
            if (name == "unsigned int") return "uint";
            if (name == "unsigned long long") return "ulong";
            
            //TODO abstract custom maps
            if (name == "Math::float2") return "Vector2";
            if (name == "UnmanagedArray") return "UnmanagedArray";
            if (name == "entt::entity") return "Entity";
            
            return name;
        }
    }
}